9.1. Internal Variables

第九章第一節 - 內部變數
---

Builtin variables:
>`內建參數：`

variables affecting bash script behavior
>`影響到 bash script 行為者，稱內建參數。`

$BASH

The path to the Bash binary itself
>`Bash binary 檔本身路徑。`

```bash
bash$ echo $BASH
/bin/bash
```

$BASH_ENV
An environmental variable pointing to a Bash startup file to be read when a script is invoked
>`以 non-interactive mode 執行 bash ，並執行某個腳本時，bash 就會查看 $BASH_ENV 這個變數值，執行變數值內所指的檔案。`

$BASH_SUBSHELL
A variable indicating the subshell level. This is a new addition to Bash, version 3.
>`指出在第幾層 subshell 中，在 Bash version 3 中是新功能。`

See Example 21-1 for usage.

$BASHPID

Process ID of the current instance of Bash. 
>`執行中 Bash instance 的 process ID。 `

This is not the same as the $$ variable, but it often gives the same result.
>`與變數 $$ 不同，但通常兩者結果相同。`

```bash
bash4$ echo $$
11015

bash4$ echo $BASHPID
11015

bash4$ ps ax | grep bash4
11015 pts/2    R      0:00 bash4
```

But...
>`但...`

```bash
#!/bin/bash4

echo "\$\$ outside of subshell = $$"                              # 9602
     #"$$ 在 subshell 之外 = $$。"
echo "\$BASH_SUBSHELL  outside of subshell = $BASH_SUBSHELL"      # 0
     #"$BASH_SUBSHELL 在 subshell 之外 = $BASH_SUBSHELL"
echo "\$BASHPID outside of subshell = $BASHPID"                   # 9602
     #"$BASHPID 在 subshell 之外 = $BASHPID"

echo

( echo "\$\$ inside of subshell = $$"                             # 9602
       #"$$ 在 subshell 之內 = $$。"
  echo "\$BASH_SUBSHELL inside of subshell = $BASH_SUBSHELL"      # 1
       #"$BASH_SUBSHELL 在 subshell 之內 = $BASH_SUBSHELL"
  echo "\$BASHPID inside of subshell = $BASHPID" )                # 9603
       #"$BASHPID 在 subshell 之內 = $BASH_SUBSHELL"
  # Note that $$ returns PID of parent process.
  # $$ 回傳 parent process 的 PID。
```

$BASH_VERSINFO[n]
A 6-element array containing version information about the installed release of Bash. 
>`大小為六的陣列，其中包含 Bash 的版本資訊。`

This is similar to $BASH_VERSION, below, but a bit more detailed.
>`與 $BASH_VERSION 相似，但提供更細部資訊。`

```bash
# Bash version info:
# Bash 版本資訊：

for n in 0 1 2 3 4 5
do
  echo "BASH_VERSINFO[$n] = ${BASH_VERSINFO[$n]}"
done  

# BASH_VERSINFO[0] = 3                      # Major version no.
											# 主要版本號。
# BASH_VERSINFO[1] = 00                     # Minor version no.
											# 次要版本號。
# BASH_VERSINFO[2] = 14                     # Patch level.
											# Patch 版本號.
# BASH_VERSINFO[3] = 1                      # Build version.
											# Build 版本號。
# BASH_VERSINFO[4] = release                # Release status.
											# 發布狀態。
# BASH_VERSINFO[5] = i386-redhat-linux-gnu  # Architecture
											# 系統架構。
                                            # (same as $MACHTYPE).
                                            # 與 $MACHTYPE 相同。
```

$BASH_VERSION
The version of Bash installed on the system
>`安裝在系統上 Bash 的版本。`

```bash
bash$ echo $BASH_VERSION
3.2.25(1)-release
```

```
tcsh% echo $BASH_VERSION
BASH_VERSION: Undefined variable.
```

Checking $BASH_VERSION is a good method of determining which shell is running. 
>`若要確認 shell 是否正在運行，檢查 $BASH_VERSION 不失為好方法。`

$SHELL does not necessarily give the correct answer.
>`$SHELL 不見得會給正確答案。`

$CDPATH
A colon-separated list of search paths available to the cd command, similar in function to the $PATH variable for binaries. >`一串以 : 隔開的目錄 list，可直接 cd 到 list 中之子目錄，與  $PATH 相似。`

The $CDPATH variable may be set in the local ~/.bashrc file.
>`$CDPATH 變數可在 ~/.bashrc 中設定。`

```bash
bash$ cd bash-doc
bash: cd: bash-doc: No such file or directory
# bash: cd: bash-doc: 沒有此檔或資料夾。

bash$ CDPATH=/usr/share/doc
bash$ cd bash-doc
/usr/share/doc/bash-doc

bash$ echo $PWD
/usr/share/doc/bash-doc
```

$DIRSTACK
The top value in the directory stack [1] (affected by pushd and popd)
>`目錄堆疊 [1] (directory stack) 中的 top value。(會受到 pushd 及 popd 影響)`

This builtin variable corresponds to the dirs command, however dirs shows the entire contents of the directory stack.
>`此變數與 dirs 指令相關，然而 dirs 會 show 出 directory stack 的所有 contents。`

$EDITOR
The default editor invoked by a script, usually vi or emacs.
>`預設使用之編輯器，通常是 vi 或 emacs。`

$EUID
"effective" user ID number
>`「有效的」使用者 ID。`

Identification number of whatever identity the current user has assumed, perhaps by means of su.
>`使用者 ID 的號碼，但使用者的 identity 有可能是使用 su 所取得的。`

Caution	
The $EUID is not necessarily the same as the $UID.
>`$EUID 不全然與 $UID 相同。`

$FUNCNAME
Name of the current function
>`執行中之函式。`

```bash
xyz23 ()
{
  echo "$FUNCNAME now executing."  # xyz23 now executing.
  								   # xyz23 執行中。
}

xyz23

echo "FUNCNAME = $FUNCNAME"        # FUNCNAME =
                                   # Null value outside a function.
                                   # 在函式外，該變數為空值。
```

See also Example A-50.
>`也可參考範例 A-50。`

$GLOBIGNORE
A list of filename patterns to be excluded from matching in globbing.
>`此變數可將特定檔案或資料夾排除在 ls 結果之外。`

$GROUPS
Groups current user belongs to
>`當前使用者所屬群組。`

This is a listing (array) of the group id numbers for current user, as recorded in /etc/passwd and /etc/group.
>`群組 id 與記錄在 /etc/passwd 及 /etc/group 中之 id 相同。`

```bash
root# echo $GROUPS
0

root# echo ${GROUPS[1]}
1

root# echo ${GROUPS[5]}
6
```

$HOME
Home directory of the user, usually /home/username (see Example 10-7)
>`使用者之家目錄，通常為 /home/username。(請參考範例 10-7)`

$HOSTNAME
The hostname command assigns the system host name at bootup in an init script. 
>`在系統 bootup 時，init script 中的 hostname 指令會設定 host name。`

However, the gethostname() function sets the Bash internal variable $HOSTNAME. 
>`然而，Bash 內部變數 $HOSTNAME 之值，則是由 gethostname() 函式所 assign。`

See also Example 10-7.
>`請看範例 10-7。`

$HOSTTYPE
host type
>`顯示系統是 x86_64 或 i386 等架構。`

Like $MACHTYPE, identifies the system hardware.
>`好比 $MACHTYPE，辨識系統硬體架構。`

```bash
bash$ echo $HOSTTYPE
i686
```

$IFS
internal field separator
>`內部字段分隔符號。`

This variable determines how Bash recognizes fields, or word boundaries, when it interprets character strings.
>`當遇見字串時，此變數決定 Bash 是如何區隔 fields 或 word。`

$IFS defaults to whitespace (space, tab, and newline), but may be changed, for example, to parse a comma-separated data file. 
>`$IFS 預設值是 whitespace (space, tab 或 newline)，但若遇到要 parse 以逗號為區隔的資料時，則會改變。`

Note that $* uses the first character held in $IFS. See Example 5-1.
>`若使用 $*，則會以 $IFS 中的第一個字元來作為區隔符號。詳見範例 5-1。`

```bash
bash$ echo "$IFS"

(With $IFS set to default, a blank line displays.)
# 若 $IFS 為預設值，則顯示一空白行。
	      
bash$ echo "$IFS" | cat -vte
 ^I$
 $
(Show whitespace: here a single space, ^I [horizontal tab],
  and newline, and display "$" at end-of-line.)
# 顯示空白：單一格空白，^I [垂直 tab 符號]，接著換行，「$」 表示行末。

bash$ bash -c 'set w x y z; IFS=":-;"; echo "$*"'
w:x:y:z
(Read commands from string and assign any arguments to pos params.)
# 設訂 position 參數，並用 "$*" 來看 IFS 所發揮的作用。
```

Set $IFS to eliminate whitespace in pathnames.
>`設定 $IFS 參數來終結在路徑名中的空白。`

IFS="$(printf '\n\t')"   # Per David Wheeler.
						 # 由 David Wheeler 提供。

$IFS does not handle whitespace the same as it does other characters.
>`$IFS 不處理空白自元。`

Example 9-1. $IFS and whitespace
>`範例 9-1。$IFS 與空白字元。`

```bash
#!/bin/bash
# ifs.sh

var1="a+b+c"
var2="d-e-f"
var3="g,h,i"

IFS=+
# The plus sign will be interpreted as a separator.
# 等號右邊的加號，在此處被視為是分隔符號。
echo $var1     # a b c
echo $var2     # d-e-f
echo $var3     # g,h,i

echo

IFS="-"
# The plus sign reverts to default interpretation.
# 加號還原成預設之加號字元 (已不是分隔符號)。`
# The minus sign will be interpreted as a separator.
# 減號將被視為分隔符號。
echo $var1     # a+b+c
echo $var2     # d e f
echo $var3     # g,h,i

echo

IFS=","
# The comma will be interpreted as a separator.
# 逗號將被視為分隔符號。
# The minus sign reverts to default interpretation.
# 減號就恢復成原本功能。
echo $var1     # a+b+c
echo $var2     # d-e-f
echo $var3     # g h i

echo

IFS=" "
# The space character will be interpreted as a separator.
# 空白字元將被視為分隔符號。
# The comma reverts to default interpretation.
# 逗號就恢復成原本的功能。
echo $var1     # a+b+c
echo $var2     # d-e-f
echo $var3     # g,h,i

# ======================================================== #

# However ...
# $IFS treats whitespace differently than other characters.
# $IFS 對空白字元的處理與對其他自元處理方式不同。

output_args_one_per_line()
{
  for arg
  do
    echo "[$arg]"
  done #  ^    ^   Embed within brackets, for your viewing pleasure.
       #           為了閱讀上的舒適，在變數外加括號。
}

echo; echo "IFS=\" \""
echo "-------"

IFS=" "
var=" a  b c   "
#    ^ ^^   ^^^
output_args_one_per_line $var  # output_args_one_per_line `echo " a  b c   "`
							   # output_args_one_per_line 會印出 " a  b c   "
# [a]
# [b]
# [c]

echo; echo "IFS=:"
echo "-----"

IFS=:
var=":a::b:c:::"               # Same pattern as above,
#    ^ ^^   ^^^                #+ but substituting ":" for " "  ...
							   #  與上面的 pattern 一樣，但會將 : 以空白取代。
output_args_one_per_line $var
# []
# [a]
# []
# [b]
# [c]
# []
# []

# Note "empty" brackets.
# 請注意空括號。
# The same thing happens with the "FS" field separator in awk.
# 在 awk 中的 FS 分隔符號中，也會有相同的現象。

echo
exit
```

(Many thanks, Stéphane Chazelas, for clarification and above examples.)
>`感謝 Stéphane Chazelas 釐清上面的範例。`

See also Example 16-41, Example 11-8, and Example 19-14 for instructive examples of using $IFS.
>`更多關於 #IFS 應用，請參考範例 16-41, 11-8 及 19-14。`

$IGNOREEOF
Ignore EOF: how many end-of-files (control-D) the shell will ignore before logging out.
>`此變數值為數字。指 shell 在 logging out 前忽略的 end-of-files (control-D) 次數。`

$LC_COLLATE
Often set in the .bashrc or /etc/profile files, this variable controls collation order in filename expansion and pattern matching. 
>`通常會在 .bashrc 或 /etc/profile 中設定，此變數控制檔名 expansion 及 pattern matching 的 collation order。`

If mishandled, LC_COLLATE can cause unexpected results in filename globbing.
>`若沒設定好，則 LC_COLLATE 會導致在 filename globbing 時產生意外的結果。`

Note	
As of version 2.05 of Bash, filename globbing no longer distinguishes between lowercase and uppercase letters in a character range between brackets. 
>`在 2.05 版 Bash中，filename globbing 不再分辨括號 (brackets) 中字元大小寫。`

For example, ls [A-M]* would match both File1.txt and file1.txt. 
>`例如，ls [A-M]* 的結果 File1.txt 及 file1.txt 皆符合。`

To revert to the customary behavior of bracket matching, set LC_COLLATE to C by an export LC_COLLATE=C in /etc/profile and/or ~/.bashrc.
>`若想恢復我們習慣的設定，則在 /etc/profile 或 ~/.bashrc 中將 LC_COLLATE 設定為 C 即可。`

$LC_CTYPE
This internal variable controls character interpretation in globbing and pattern matching.
>`此內部店數控制著在 globbing 及 pattern matching 時的 character interpretation。`

$LINENO
This variable is the line number of the shell script in which this variable appears. 
>`此變數值為，「放置在腳本中，此變數所在之行數。」`

It has significance only within the script in which it appears, and is chiefly useful for debugging purposes.
>`此變數大多數使用在腳本中，且主要使用目的在於偵錯與抓蟲。`

```bash
# *** BEGIN DEBUG BLOCK ***
# *** DEBUG 區塊起始處 ***
last_cmd_arg=$_  # Save it.


echo "At line number $LINENO, variable \"v1\" = $v1"
# 在第 $LINENO，"v1" 參數值為 $v1。
echo "Last command argument processed = $last_cmd_arg"
# 最後處理的 command argument = $last_cmd_arg。
# *** END DEBUG BLOCK ***
# *** DEBUG 區塊終止處 ***
```

$MACHTYPE
machine type

Identifies the system hardware.
>`辨識系統之硬體資訊。`

```bash
bash$ echo $MACHTYPE
i686
```

$OLDPWD
Old working directory ("OLD-Print-Working-Directory", previous directory you were in).
>`使用者所在之前一個目錄。`

$OSTYPE
operating system type
>`作業系統類型。`

```bash
bash$ echo $OSTYPE
linux
```

$PATH
Path to binaries, usually /usr/bin/, /usr/X11R6/bin/, /usr/local/bin, etc.
>`二進位檔的路徑，通常是 /usr/bin、/usr/X11R6/bin、/usr/local/bin 等。`

When given a command, the shell automatically does a hash table search on the directories listed in the path for the executable. 
>`當下達一指令時，shell 自動從 path 中的目錄做 hash table search，尋找可執行檔。`

The path is stored in the environmental variable, $PATH, a list of directories, separated by colons. 
>`路徑通常是存放在變數 $PATH 中。$PATH 是一串字串，以冒號將不同目錄做區隔。`

Normally, the system stores the $PATH definition in /etc/profile and/or ~/.bashrc (see Appendix H).
>`通常系統將 $PATH 的定義存放在 /etc/profile 及/或 ~/.bashrc 中。(詳見附錄H)`

```bash
bash$ echo $PATH
/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin:/sbin:/usr/sbin
```

PATH=${PATH}:/opt/bin appends the /opt/bin directory to the current path. 
>`/opt/bin 被附加在現有的 path 後面。`

In a script, it may be expedient to temporarily add a directory to the path in this way. 
>`在腳本中，path 也可能被特別制訂。`

When the script exits, this restores the original $PATH (a child process, such as a script, may not change the environment of the parent process, the shell).
>`當腳本執行結束時，原本的 $PATH 就會被還原。(子程序如腳本，是無法改變父程序(the shell)的環境變數值。)`


Note	
The current "working directory", ./, is usually omitted from the $PATH as a security measure.
>`注意，現所在資料夾 "./" 因安全上考量，在 $PATH 中已預設。`

$PIPESTATUS
Array variable holding exit status(es) of last executed foreground pipe.
>`pipe 最後一個執行指令的退出狀態值。`

```bash
bash$ echo $PIPESTATUS
0

bash$ ls -al | bogus_command
bash: bogus_command: command not found
bash$ echo ${PIPESTATUS[1]}
127

bash$ ls -al | bogus_command
bash: bogus_command: command not found
bash$ echo $?
127
```

The members of the $PIPESTATUS array hold the exit status of each respective command executed in a pipe. 
>`$PIPESTATUS 陣列中存放有每個 pipe 指令的退出狀態值。`

$PIPESTATUS[0] holds the exit status of the first command in the pipe, $PIPESTATUS[1] the exit status of the second command, and so on.
>`$PIPESTATUS[0] 存放在 pipe 中第一個執行結果退出狀態，而 $PIPESTATUS[1] 則存放第二個執行結果退出狀態。`

Caution	
The $PIPESTATUS variable may contain an erroneous 0 value in a login shell (in releases prior to 3.0 of Bash).
>`注意，$PIPESTATUS 在 Bash 3.0 之前的版本，在 login shell 中可能會存有 erroneous 0 值。`

```
tcsh% bash

bash$ who | grep nobody | sort
bash$ echo ${PIPESTATUS[*]}
0
```

The above lines contained in a script would produce the expected 0 1 0 output.
>`上面指令若以一腳本執行後預期會輸出 0 1 0。`

Thank you, Wayne Pollock for pointing this out and supplying the above example.
>`感謝 Wayne Pollock 提供上述範例。`

Note	
The $PIPESTATUS variable gives unexpected results in some contexts.
>`注意：$PIPESTATUS 變數在 some contexts 下，會出現非預期結果。`

```bash
bash$ echo $BASH_VERSION
3.00.14(1)-release

bash$ $ ls | bogus_command | wc
bash: bogus_command: command not found
 0       0       0

bash$ echo ${PIPESTATUS[@]}
141 127 0
```

Chet Ramey attributes the above output to the behavior of ls. 
>`Chet Ramey 將 ls 行為的特性指出。`

If ls writes to a pipe whose output is not read, then SIGPIPE kills it, and its exit status is 141. 
>`若 ls 傳給 pipe 的東西無法被解讀，則 SIGPIPE 就會 kill 掉它，且退出狀態是 141。`

Otherwise its exit status is 0, as expected. 
>`否則它的退出狀態會如預期，為 0 值。`

This likewise is the case for tr.
>`tr 指令也會有類似情形。`

Note	
$PIPESTATUS is a "volatile" variable. 
>`請注意，$PIPESTATUS 是「可揮發性」的變數。`

It needs to be captured immediately after the pipe in question, before any other command intervenes.
>`手腳要快，須在被其他指令干擾前，立刻捕捉該值。`

```bash
bash$ $ ls | bogus_command | wc
bash: bogus_command: command not found
 0       0       0

bash$ echo ${PIPESTATUS[@]}
0 127 0

bash$ echo ${PIPESTATUS[@]}
0
```

Note
The pipefail option may be useful in cases where $PIPESTATUS does not give the desired information.
>`注意：pipefail 選項在 $PIPESTATUS 無法給出 desired information 時，可能會派上用場。`

$PPID
The $PPID of a process is the process ID (pid) of its parent process. [2]
>`$PPID 為 process 的 parent process ID。`

Compare this with the pidof command.
>`此變數可與 pidof 指令相比。`

$PROMPT_COMMAND
A variable holding a command to be executed just before the primary prompt, $PS1 is to be displayed.
>`在 primary prompt (也就是 $PS1 被 prompted) 之前，該變數存放即將被執行的指令。`

$PS1
This is the main prompt, seen at the command-line.
>`這是 main prompt，在 command-line 可見。`

$PS2
The secondary prompt, seen when additional input is expected. It displays as ">".
>`這是 secondary prompt，通常在輸入特定關鍵字時才出現。它通常顯示為 ">"。`

$PS3
The tertiary prompt, displayed in a select loop (see Example 11-30).
>`第三個 prompt，詳見範例 11-30。`

$PS4
The quartenary prompt, shown at the beginning of each line of output when invoking a script with the -x [verbose trace] option. It displays as "+".
>`若腳本內設定 -x 參數，則會出現以「+」為開頭之提示。`

As a debugging aid, it may be useful to embed diagnostic information in $PS4.
>`在 $PS4 中可加入一些診斷資訊協助除錯。`

P4='$(read time junk < /proc/$$/schedstat; echo "@@@ $time @@@ " )'
# Per suggestion by Erik Brandsberg.
set -x
# Various commands follow ...

$PWD
Working directory (directory you are in at the time)
>`工作目錄 (當前所在之目錄)`

This is the analog to the pwd builtin command.
>`很像內建的 pwd 指令。`

```bash
#!/bin/bash

E_WRONG_DIRECTORY=85

clear # Clear the screen.
	  # 清理螢幕上訊息。

TargetDirectory=/home/bozo/projects/GreatAmericanNovel

cd $TargetDirectory
echo "Deleting stale files in $TargetDirectory."
# 刪除 $TargetDirectory 中的老舊檔案。

if [ "$PWD" != "$TargetDirectory" ]
then    # Keep from wiping out wrong directory by accident.
		# 避免意外刪除非目標目錄。
  echo "Wrong directory!"
  		# 錯誤的目錄！
  echo "In $PWD, rather than $TargetDirectory!"
  		# 在 $PWD 而非在 $TargetDirectory ！
  echo "Bailing out!"
       "救命啊！"
  exit $E_WRONG_DIRECTORY
fi  

rm -rf *
rm .[A-Za-z0-9]*    # Delete dotfiles.
					# 刪除 dotfiles。
# rm -f .[^.]* ..?*   to remove filenames beginning with multiple dots.
# 移除檔名中有許多 . 的檔案。
# (shopt -s dotglob; rm -f *)   will also work.
# (shopt -s dotglob; rm -f *) 也可以。
# Thanks, S.C. for pointing this out.
# 感謝 S.C. 指出這一點。

#  A filename (`basename`) may contain all characters in the 0 - 255 range,
#+ except "/".
# 檔名除了 / 之外，可用 0-255 範圍中的字元組成。
#  Deleting files beginning with weird characters, such as -
#+ is left as an exercise. (Hint: rm ./-weirdname or rm -- -weirdname)
# 刪除以怪異字元為檔名開頭之檔案 (例如：- 字元)就當作是課後練習。(提示：rm ./-weirdname 或 rm -- -weirdname)
result=$?   # Result of delete operations. If successful = 0.
			# 刪除指令之退出狀態。若 successful = 0。

echo
ls -al              # Any files left?
					# 有檔案沒刪除嗎？
echo "Done."
echo "Old files deleted in $TargetDirectory."
>`在 $TargetDirectory 中的舊檔已刪除。`
echo

# Various other operations here, as necessary.
# 可自行加入其他必要的操作。

exit $result
```

$REPLY
The default value when a variable is not supplied to read. 
>`當一變數是 not supplied to read 時，該變數預設值。`

Also applicable to select menus, but only supplies the item number of the variable chosen, not the value of the variable itself.
>`同理可套在 select menus 上，但只可應用在 item number of the variable chosen，而無法應用在 variable itself。`

```bash
#!/bin/bash
# reply.sh

# REPLY is the default value for a 'read' command.
# REPLY 是 'read' 指令的預設值。

echo
echo -n "What is your favorite vegetable? "
# 你最喜歡的蔬菜為何？
read

echo "Your favorite vegetable is $REPLY."
# 你最喜歡的蔬菜是 $REPLY。
#  REPLY holds the value of last "read" if and only if
#+ no variable supplied.
# REPLY 得值就是最後的 "read"值(如果沒有其他變數 supplied 的話)。

echo
echo -n "What is your favorite fruit? "
# 你最喜歡的水果是？
read fruit
echo "Your favorite fruit is $fruit."
# 你最喜歡的水果是 $fruit。
echo "but..."
# 但是...
echo "Value of \$REPLY is still $REPLY."
# \$REPLY 的值還是 $REPLY。
#  $REPLY is still set to its previous value because
#+ the variable $fruit absorbed the new "read" value.
#  $REPLY 還是維持上一個值，因為 $fruit 吸收了新的 "read" 值。

echo

exit 0
```

$SECONDS
The number of seconds the script has been running.
>`腳本運行秒數。`

```bash
#!/bin/bash

TIME_LIMIT=10
INTERVAL=1

echo
echo "Hit Control-C to exit before $TIME_LIMIT seconds."
# 在 $TIME_LIMIT 秒數到之前，按 Control-C 退出程式。
echo

while [ "$SECONDS" -le "$TIME_LIMIT" ]
do   #   $SECONDS is an internal shell variable.
	 #   $SECONDS 是內部 shell 變數。
  if [ "$SECONDS" -eq 1 ]
  then
    units=second
  else  
    units=seconds
  fi

  echo "This script has been running $SECONDS $units."
  	   # 此腳本運行 $SECOND $units。
  #  On a slow or overburdened machine, the script may skip a count
  #+ every once in a while.
  #  在運行較慢或操過頭的機器上運行此腳本，每過一段時間，每秒可能會略過一個 count。
  sleep $INTERVAL
done

echo -e "\a"  # Beep!

exit 0
```

$SHELLOPTS
The list of enabled shell options, a readonly variable.
>`顯示可用的 shell options，此變數唯讀。`

```bash
bash$ echo $SHELLOPTS
braceexpand:hashall:histexpand:monitor:history:interactive-comments:emacs
```

$SHLVL
Shell level, how deeply Bash is nested. 
>`Shell level，顯示現在是第幾層 Bash 中。`

[3] If, at the command-line, $SHLVL is 1, then in a script it will increment to 2.
>`若在 command-line 上，$SHLVL 值為 1，則在腳本中該值會增加為 2。`

Note	
This variable is not affected by subshells. 
>`此變數不會受到 subshells 的影響。`

Use $BASH_SUBSHELL when you need an indication of subshell nesting.
>`若需要 subshell nesting 的 indication，請用 $BASH_SUBSHELL。`

$TMOUT
If the $TMOUT environmental variable is set to a non-zero value time, then the shell prompt will time out after $time seconds. This will cause a logout.
>`若環境變數 $TMOUT 值設定為非零，則 shell prompt 就會在 $time 秒後 time out。也就是會 logout 的意思。`

As of version 2.05b of Bash, it is now possible to use $TMOUT in a script in combination with read.
>`在 2.05b 版 Bash 中，$TMOUT 可在腳本中與 read 結合使用。`

```bash
# Works in scripts for Bash, versions 2.05b and later.
# Bash 2.05b 之後版本皆可用。

TMOUT=3    # Prompt times out at three seconds.
		   # 在腳本執行第三秒時會跳出 times out。

echo "What is your favorite song?"
# 最喜歡的歌曲是？
echo "Quickly now, you only have $TMOUT seconds to answer!"
# 快，您只剩下 $TMOUT 可以回答！
read song

if [ -z "$song" ]
then
  song="(no answer)"
  # Default response.
  # 預設回應。
fi

echo "Your favorite song is $song."
# 您最喜歡的歌曲是 $song。
```

There are other, more complex, ways of implementing timed input in a script. 
>`有其他更複雜的方法在腳本中使用 timed input。`

One alternative is to set up a timing loop to signal the script when it times out. 
>`替代方案是用一個 timing 迴圈，在腳本 times out 時發出訊號告知。`

This also requires a signal handling routine to trap (see Example 32-5) the interrupt generated by the timing loop (whew!).
>`同時也需要一個 signal handling routine 來捕捉 timing loop 所產生的 interrupt。`

Example 9-2. Timed Input

```bash
#!/bin/bash
# timed-input.sh

# TMOUT=3    Also works, as of newer versions of Bash.
# TMOUT=3 	 同樣適用於對較新版的 Bash。 

TIMER_INTERRUPT=14
TIMELIMIT=3  # Three seconds in this instance.
			 # 在此 instance 中是三秒鐘。
             # May be set to different value.
             # 或可設其他值。

PrintAnswer()
{
  if [ "$answer" = TIMEOUT ]
  then
    echo $answer
  else       # Don't want to mix up the two instances. 
  			 # 不想將兩個 instance 搞混。
    echo "Your favorite veggie is $answer"
    	 # 您最喜歡的蔬菜是 $answer。
    kill $!  #  Kills no-longer-needed TimerOn function
             #+ running in background.
             #  不需要 kills 拉，因為 TimerOn 函式跑在背景。
             #  $! is PID of last job running in background.
             #  $! 就是最後一個跑在背景 job 的 PID。
  fi

}  


TimerOn()
{
  sleep $TIMELIMIT && kill -s 14 $$ &
  # Waits 3 seconds, then sends sigalarm to script.
  # 等三秒，接著送 sigalarm 給腳本。
}  


Int14Vector()
{
  answer="TIMEOUT"
  PrintAnswer
  exit $TIMER_INTERRUPT
}  

trap Int14Vector $TIMER_INTERRUPT
# Timer interrupt (14) subverted for our purposes.
# Timer interrupt (14) 顛覆了我們的目的。

echo "What is your favorite vegetable "
     # 您最喜歡的蔬菜是？
TimerOn
read answer
PrintAnswer


#  Admittedly, this is a kludgy implementation of timed input.
#  必須承認，這個 timed input 是有缺陷的。
#  However, the "-t" option to "read" simplifies this task.
#  -t 選項對於 read 來說，可簡化該 task。
#  See the "t-out.sh" script.
#  詳見 "t-out.sh" 腳本。
#  However, what about timing not just single user input,
#+ but an entire script?
#  如果 timing 不只有單一使用者輸入，而是整個腳本呢？

#  If you need something really elegant ...
#+ consider writing the application in C or C++,
#+ using appropriate library functions, such as 'alarm' and 'setitimer.'
#  若想寫出優雅程式碼，建議使用 C 或 C++ 中的函式庫，例如：alarm 及 setitimer。

exit 0
```

An alternative is using stty.
>`另外的解法是使用 stty。`

Example 9-3. Once more, timed input
>`範例 9-3。再一次，timed input。`

```bash
#!/bin/bash
# timeout.sh

#  Written by Stephane Chazelas,
#+ and modified by the document author.
# 由 Stephane Chazelas 撰寫，由文件作者修改。

INTERVAL=5                # timeout interval

timedout_read() {
  timeout=$1
  varname=$2
  old_tty_settings=`stty -g`
  stty -icanon min 0 time ${timeout}0
  eval read $varname      # or just  read $varname
  stty "$old_tty_settings"
  # See man page for "stty."
  # 請查看 stty 的 man page。
}

echo; echo -n "What's your name? Quick! "
			  "你的名字是？快輸入！"
timedout_read $INTERVAL your_name

#  This may not work on every terminal type.
#  不是每種 terminal type 都可運行此腳本。
#  The maximum timeout depends on the terminal.
#  不同 terminal 有不同的 maximum timeout。
#+ (it is often 25.5 seconds).
#  (通常是 25.5 秒。)

echo

if [ ! -z "$your_name" ]  # If name input before timeout ...
						  # 如果在 timeout 前輸入名字 ...
then
  echo "Your name is $your_name."
  	  # 你的名字是 $your_name。
else
  echo "Timed out."
       # 時間到。
fi

echo

# The behavior of this script differs somewhat from "timed-input.sh."
# 此腳本的行為與 timed-input.sh 還是有些不同。
# At each keystroke, the counter resets.
# 每打一個字，計數器便重新計算。

exit 0
```

Perhaps the simplest method is using the -t option to read.
>`或許最簡單的方式就是加上 -t 參數來讀取。`

Example 9-4. Timed read
>`範例 9-4 有時間限制 read`

```bash
#!/bin/bash
# t-out.sh [time-out]
# Inspired by a suggestion from "syngin seven" (thanks).
# 感謝 syngin seven 讓我得到撰寫此腳本的靈感。


TIMELIMIT=4         # 4 seconds

read -t $TIMELIMIT variable <&1
#                           ^^^
#  In this instance, "<&1" is needed for Bash 1.x and 2.x,
#  but unnecessary for Bash 3+.
#  在這個 instance 中，若 Bash 版本是 1.x 及 2.x 則 "<&1" 是必要的，但若版本是 3+，就不需要。

echo

if [ -z "$variable" ]  # Is null?
then
  echo "Timed out, variable still unset."
  	  # 時間到，變數尚未設定。
else  
  echo "variable = $variable"
fi  

exit 0
```

$UID
User ID number
>`使用者 ID 號碼。`

Current user's user identification number, as recorded in /etc/passwd
>`當前使用者的 user identification nuber，記錄在 /etc/passwd 中。`

This is the current user's real id, even if she has temporarily assumed another identity through su. 
>`這是當前使用者的真實 id，即使該使用者正在用 su。`

$UID is a readonly variable, not subject to change from the command line or within a script, and is the counterpart to the id builtin.
>`$UID 是一唯讀變數，但在指令列上或腳本中改變該變數這動作不受限制，因為它是 id builtin 的副本。`

Example 9-5. Am I root?
>`範例 9-5。我是 root 嗎？`

```bash
#!/bin/bash
# am-i-root.sh:   Am I root or not?
# am-i-root.sh:   我是否為 root？

ROOT_UID=0   # Root has $UID 0.

if [ "$UID" -eq "$ROOT_UID" ]  # Will the real "root" please stand up?
							   # 阿姆梗，請 root 起立。
then
  echo "You are root."
  	  #"你是 root。"
else
  echo "You are just an ordinary user (but mom loves you just the same)."
       "你只是一個普通權限使用者。(別擔心，媽媽一樣愛你。)"
fi

exit 0


# ============================================================= #
# Code below will not execute, because the script already exited.
# 下面的 code 不會被執行，因腳本已經 exited。

# An alternate method of getting to the root of matters:
# 另一偵測是否為 root 之方法。

ROOTUSER_NAME=root

username=`id -nu`              # Or...   username=`whoami`
if [ "$username" = "$ROOTUSER_NAME" ]
then
  echo "Rooty, toot, toot. You are root."
  	   #"你是 root！"
else
  echo "You are just a regular fella."
      #"你只是一個普通權限使用者。"
fi
```

See also Example 2-3.
>`請看範例 2-3。`

Note	
The variables $ENV, $LOGNAME, $MAIL, $TERM, $USER, and $USERNAME are not Bash builtins. 
>`請注意，$ENV, $LOGNAME, $MAIL, $TERM, $USER 及 $USERNAME 都不是 Bash 內建的。`

These are, however, often set as environmental variables in one of the Bash or login startup files. 
>`這些變數通常在 Bash 或 login startup 檔案中被設為環境變數。`

$SHELL, the name of the user's login shell, may be set from /etc/passwd or in an "init" script, and it is likewise not a Bash builtin.
>`$SHELL，使用者 login shell 的名稱，可在 /etc/passwd 中或 init script 中被設定，且同樣的，它也不是 Bash 內建變數。`


```
tcsh% echo $LOGNAME
bozo
tcsh% echo $SHELL
/bin/tcsh
tcsh% echo $TERM
rxvt

bash$ echo $LOGNAME
bozo
bash$ echo $SHELL
/bin/tcsh
bash$ echo $TERM
rxvt
```

Positional Parameters
>`位置參數`


$0, $1, $2, etc.
>`例如 $0, $1, $2 等。`

Positional parameters, passed from command line to script, passed to a function, or set to a variable (see Example 4-5 and Example 15-16)
>`位置參數，將指令列的參數傳遞到腳本中、或透過函式傳遞、將值設定給某個變數 (詳見範例 4-5 及範例 15-16)`

$#
Number of command-line arguments [4] or positional parameters (see Example 36-2)
>`指令列參數或位置參數(詳見範例 36-2)的數目[4]。`

$*
All of the positional parameters, seen as a single word
>`所有的位置參數，以 single word 呈現。`

Note	
"$*" must be quoted.
>`注意，$* 必須被雙引號包起來。`

$@
Same as $*, but each parameter is a quoted string, that is, the parameters are passed on intact, without interpretation or expansion. 
>`跟 $* 相同，但每個 parameter都是一個 quoted string，也就是說，parameters 都是直接被 passed 的，沒有經過其他 interpretation 或 expansion。` 

This means, among other things, that each parameter in the argument list is seen as a separate word.
>`這表示，每個在列表中的參數都被視為是一個單獨的字。`

Note	
Of course, "$@" should be quoted.
>`當然，"$@" 應該要被 quoted。`

Example 9-6. arglist: Listing arguments with $* and $@
>`範例 9-6. arglist: 用 $* 與 $@ 列出參數。`

```bash
#!/bin/bash
# arglist.sh
# Invoke this script with several arguments, such as "one two three" ...
# 用幾個參數(例如：one two three)觸發此腳本。

E_BADARGS=85

if [ ! -n "$1" ]
then
  echo "Usage: `basename $0` argument1 argument2 etc."
  	  # 使用方法：basename $0 參數1 參數2 等
  exit $E_BADARGS
fi  

echo

index=1          # Initialize count.

echo "Listing args with \"\$*\":"
# 用 $* 列出參數。
for arg in "$*"  # Doesn't work properly if "$*" isn't quoted.
		 # 若 $* 沒被 quote，則無法順利使用。
do
  echo "Arg #$index = $arg"
  let "index+=1"
done             # $* sees all arguments as single word.
			     # 將所有 arguments 視為單詞。
echo "Entire arg list seen as single word."
	 # 整個參數列表都被視為單詞。

echo

index=1          # Reset count.
				 # 重新計數。
                 # What happens if you forget to do this?
                 # 若忘記了該怎麼辦？

echo "Listing args with \"\$@\":"
for arg in "$@"
do
  echo "Arg #$index = $arg"
  let "index+=1"
done             # $@ sees arguments as separate words.
			     # $@ 視參數為 separate words。 
echo "Arg list seen as separate words."
	 # 參數列表被視為 separate words。

echo

index=1          # Reset count.

echo "Listing args with \$* (unquoted):"
  	 # 用 $* (無引號) 列出參數。
for arg in $*
do
  echo "Arg #$index = $arg"
  let "index+=1"
done             # Unquoted $* sees arguments as separate words.
				 # unquoted $* 將 arguments 視為 separate words。
echo "Arg list seen as separate words."
	# 參數列表被視為 separate words。
exit 0
```

Following a shift, the $@ holds the remaining command-line parameters, lacking the previous $1, which was lost.
>`若再加按 shift 鍵，則只會保留 $1 之後的參數。`

```bash
#!/bin/bash
# Invoke with ./scriptname 1 2 3 4 5
# 用 ./scriptname 1 2 3 4 5 來觸發。

echo "$@"    # 1 2 3 4 5
shift
echo "$@"    # 2 3 4 5
shift
echo "$@"    # 3 4 5

# Each "shift" loses parameter $1.
# 每輸入一次 shift 指令就會失去參數 $1。
# "$@" then contains the remaining parameters.
# "$@" 包含剩餘之參數。
```

The $@ special parameter finds use as a tool for filtering input into shell scripts. 
>`特殊參數 $@ 被用以過濾輸入到腳本的內容(參數)。`

The cat "$@" construction accepts input to a script either from stdin or from files given as parameters to the script.
>`cat "$@" construction 接受從 stdin 或檔案 (以檔名為參數方式) 輸入腳本。`

See Example 16-24 and Example 16-25.
>`詳見範例 16-24 及範例 16-25。`

Caution	
The $* and $@ parameters sometimes display inconsistent and puzzling behavior, depending on the setting of $IFS.
>`注意，$* 與 $@ 兩者有時會因 $IFS 設定不同，而顯示不一致且讓人迷惑之結果。`

Example 9-7. Inconsistent $* and $@ behavior
>`範例 9-7。$* 與 $@ 不一致的行為。`

```bash
#!/bin/bash

#  Erratic behavior of the "$*" and "$@" internal Bash variables,
#+ depending on whether or not they are quoted.
#  內建 Bash 變數 "$*" 與 "$@" 古怪行為取決於是否有用引號。
#  Demonstrates inconsistent handling of word splitting and linefeeds.
#  演示對於切字與換行符之處理差異。

set -- "First one" "second" "third:one" "" "Fifth: :one"
# Setting the script arguments, $1, $2, $3, etc.
# 設定腳本參數 $1, $2, $3 等。

echo

echo 'IFS unchanged, using "$*"'
	 # IFS 不變，用 $*。
c=0
for i in "$*"               # quoted
							# 使用雙引號
do echo "$((c+=1)): [$i]"   # This line remains the same in every instance.
							# 此行每次 instance 發生時，都維持相同。
                            # Echo args.
                            # 印出參數。
done
echo ---

echo 'IFS unchanged, using $*'
	 # IFS 不變，用 $*。
c=0
for i in $*                 # unquoted
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS unchanged, using "$@"'
	 #IFS 不變，用 "$@"。
c=0
for i in "$@"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS unchanged, using $@'
	 # IFS 不變，用 $@。
c=0
for i in $@
do echo "$((c+=1)): [$i]"
done
echo ---

IFS=:
echo 'IFS=":", using "$*"'
 	 # IFS = ":"，用 "$*"
c=0
for i in "$*"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using $*'
	 # IFS=":"，用 $*
c=0
for i in $*
do echo "$((c+=1)): [$i]"
done
echo ---

var=$*
echo 'IFS=":", using "$var" (var=$*)'
     # IFS=":"，用 "$var" var=$*
c=0
for i in "$var"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using $var (var=$*)'
	 # IFS=":"，用 $var (var=$*)
c=0
for i in $var
do echo "$((c+=1)): [$i]"
done
echo ---

var="$*"
echo 'IFS=":", using $var (var="$*")'
	 # IFS=":"，用 $var (var="$*")
c=0
for i in $var
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using "$var" (var="$*")'
	 # IFS=":"，用 "$var" (var="$*")
c=0
for i in "$var"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using "$@"'
	 # IFS=":"，用 "$@"
c=0
for i in "$@"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using $@'
	 # IFS=":"，用 $@
c=0
for i in $@
do echo "$((c+=1)): [$i]"
done
echo ---

var=$@
echo 'IFS=":", using $var (var=$@)'
	 # IFS=":"，用 $var (var=$@)
c=0
for i in $var
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using "$var" (var=$@)'
	 # IFS=":"，用 "$var" (var=$@)
c=0
for i in "$var"
do echo "$((c+=1)): [$i]"
done
echo ---

var="$@"
echo 'IFS=":", using "$var" (var="$@")'
	 # IFS=":"，用 "$var" (var="$@")
c=0
for i in "$var"
do echo "$((c+=1)): [$i]"
done
echo ---

echo 'IFS=":", using $var (var="$@")'
	 # IFS=":"，用 $var (var="$@")
c=0
for i in $var
do echo "$((c+=1)): [$i]"
done

echo

# Try this script with ksh or zsh -y.
# 用 ksh 或 zsh -y 試跑這隻腳本。

exit 0

#  This example script written by Stephane Chazelas,
#+ and slightly modified by the document author.
# 此範例由 Stephane Chazelas 撰寫，由本件作者做些微改寫。
```


Note	
The $@ and $* parameters differ only when between double quotes.
>`註： 使用 $@ 與 $* 參數之差異，在於雙引號使用與否。`

Example 9-8. $* and $@ when $IFS is empty
>`範例 9-8。 當 $IFS 是空值時使用 $* 與 $@ 的情況。`

```bash
#!/bin/bash

#  If $IFS set, but empty,
#+ then "$*" and "$@" do not echo positional params as expected.
# 若 $IFS 設定為空值，則 "$*" 與 "$@" 就不會如預期印出位置參數值。

mecho ()       # Echo positional parameters. 印出位置參數值。
{
echo "$1,$2,$3";
}


IFS=""         # Set, but empty.
			   # IFS 有設定，但為空值。
set a b c      # Positional parameters.
			   # 位置參數。

mecho "$*"     # abc,,
#                   ^^
mecho $*       # a,b,c

mecho $@       # a,b,c
mecho "$@"     # a,b,c

#  The behavior of $* and $@ when $IFS is empty depends
#+ on which Bash or sh version being run.
#  當 $IFS 為空值時，$* 與 $@ 的行為，依據 Bash 或 sh 的版本差異，而有所不同。
#  It is therefore inadvisable to depend on this "feature" in a script.
#  因此建議不在腳本中依賴此 feature。

# Thanks, Stephane Chazelas.
# 感謝 Stephane Chazelas。

exit
```

Other Special Parameters
>`其他特殊參數`

$-
Flags passed to script (using set). See Example 15-16.
>`傳至 script 中的 Flags (用 set)。詳見範例 15-16。`

Caution	
This was originally a ksh construct adopted into Bash, and unfortunately it does not seem to work reliably in Bash scripts. 
>`注意：這原本是 ksh construct，不幸的是它似乎在 Bash 腳本中較不可靠。`

One possible use for it is to have a script self-test whether it is interactive.
>`另一種可能用法為腳本自我測試，測試腳本是否有可互動性。`

$!
PID (process ID) of last job run in background

```bash
LOG=$0.log

COMMAND1="sleep 100"

echo "Logging PIDs background commands for script: $0" >> "$LOG"
# So they can be monitored, and killed as necessary.
echo >> "$LOG"

# Logging commands.

echo -n "PID of \"$COMMAND1\":  " >> "$LOG"
${COMMAND1} &
echo $! >> "$LOG"
# PID of "sleep 100":  1506

# Thank you, Jacques Lederer, for suggesting this.
```

Using $! for job control:

```bash
possibly_hanging_job & { sleep ${TIMEOUT}; eval 'kill -9 $!' &> /dev/null; }
# Forces completion of an ill-behaved program.
# Useful, for example, in init scripts.

# Thank you, Sylvain Fourmanoit, for this creative use of the "!" variable.
```

Or, alternately:

```bash
# This example by Matthew Sage.
# Used with permission.

TIMEOUT=30   # Timeout value in seconds
count=0

possibly_hanging_job & {
        while ((count < TIMEOUT )); do
                eval '[ ! -d "/proc/$!" ] && ((count = TIMEOUT))'
                # /proc is where information about running processes is found.
                # "-d" tests whether it exists (whether directory exists).
                # So, we're waiting for the job in question to show up.
                ((count++))
                sleep 1
        done
        eval '[ -d "/proc/$!" ] && kill -15 $!'
        # If the hanging job is running, kill it.
}

#  -------------------------------------------------------------- #

#  However, this may not not work as specified if another process
#+ begins to run after the "hanging_job" . . .
#  In such a case, the wrong job may be killed.
#  Ariel Meragelman suggests the following fix.

TIMEOUT=30
count=0
# Timeout value in seconds
possibly_hanging_job & {

while ((count < TIMEOUT )); do
  eval '[ ! -d "/proc/$lastjob" ] && ((count = TIMEOUT))'
  lastjob=$!
  ((count++))
  sleep 1
done
eval '[ -d "/proc/$lastjob" ] && kill -15 $lastjob'

}

exit
```

$_
Special variable set to final argument of previous command executed.

Example 9-9. Underscore variable

```bash
#!/bin/bash

echo $_              #  /bin/bash
                     #  Just called /bin/bash to run the script.
                     #  Note that this will vary according to
                     #+ how the script is invoked.

du >/dev/null        #  So no output from command.
echo $_              #  du

ls -al >/dev/null    #  So no output from command.
echo $_              #  -al  (last argument)

:
echo $_              #  :
```

$?
Exit status of a command, function, or the script itself (see Example 24-7)

$$
Process ID (PID) of the script itself. [5] The $$ variable often finds use in scripts to construct "unique" temp file names (see Example 32-6, Example 16-31, and Example 15-27). This is usually simpler than invoking mktemp.

Notes

[1]	
A stack register is a set of consecutive memory locations, such that the values stored (pushed) are retrieved (popped) in reverse order. The last value stored is the first retrieved. This is sometimes called a LIFO (last-in-first-out) or pushdown stack.

[2]	
The PID of the currently running script is $$, of course.

[3]	
Somewhat analogous to recursion, in this context nesting refers to a pattern embedded within a larger pattern. One of the definitions of nest, according to the 1913 edition of Webster's Dictionary, illustrates this beautifully: "A collection of boxes, cases, or the like, of graduated size, each put within the one next larger."

[4]	
The words "argument" and "parameter" are often used interchangeably. In the context of this document, they have the same precise meaning: a variable passed to a script or function.

[5]	
Within a script, inside a subshell, $$ returns the PID of the script, not the subshell.

ref: http://tldp.org/LDP/abs/html/internalvariables.html
